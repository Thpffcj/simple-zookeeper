# 基于Zookeeper解决常见分布式问题

- ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务
- ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户
- ZooKeeper包含一个简单的原语集，提供Java和C的接口

## 1. 简介

学习Zookeeper也有一段时间了，我想从实际的分布式应用场景出发，来学习如何使用Zookeeper去解决一些常见的分布式问题，对常见应用场景主要提供Java原生API和Curator两种实现方式

### 1. Zookeeper

Zookeeper作为一个分布式服务框架，主要用来解决分布式数据一致性问题，它提供了简单的分布式原语，并且对多种编程语言提供了API，我们重点使用Zookeeper的Java客户端API实现常用应用场景。

### 2. Curator

为了更好的实现Java操作Zookeeper服务器，后来出现了Curator框架，非常的强大，目前已经是Apache的顶级项目，里面提供了更多丰富的操作，例如session超时重连、主从选举、分布式计数器、分布式锁等等适用于各种复杂的zookeeper场景的API封装。

## 2. 常用场景

### 1. 数据发布/订阅

- 数据发布/订阅(Publish/Subscribe)系统，即所谓的配置中心，顾名思义就是发布者将数据发布到ZooKeeper的一个或一系列节点上，供订阅者进行数据订阅，进而达到动态获取数据的目的，实现配置信息的集中式管理和数据的动态更新。
- 发布/订阅系统一般有两种设计模式，分别是推(Push) 模式和拉(Pull) 模式。在推模式中，服务端主动将数据更新发送给所有订阅的客户端；而拉模式则是由客户端主动发起请求来获取最新数据，通常客户端都采用定时进行轮询拉取的方式。
- ZooKeeper采用的是推拉相结合的方式：客户端向服务端注册自己需要关注的节点，一旦该节点的数据发生变更，那么服务端就会向相应的客户端发送Watcher事件通知，客户端接收到这个消息通知之后，需要主动到服务端获取最新的数据。
- 如果将配置信息存放到ZooKeeper上进行集中管理，那么通常情况下，应用在启动的时候都会主动到ZooKeeper服务端上进行--次配置信息的获取，同时，在指定节点上注册一个Watcher监听，这样--来，但凡配置信息发生变更，服务端都会实时通知到所有订阅的客户端，从而达到实时获取最新配置信息的目的。

### 2. 负载均衡

- 负载均衡(Load Balance)是一种相当常见的计算机网络技术，用来对多个计算机(计算机集群)、网络连接、CPU、磁盘驱动器或其他资源进行分配负载，以达到优化资源使用、最大化吞吐率、最小化响应时间和避免过载的目的。通常负载均衡可以分为硬件和软件负载均衡两类，我们主要探讨的是ZooKeeper在“软”负载均衡中的应用场景。
- 分布式系统具有对等性，为了保证系统的高可用性，通常采用副本的方式来对数据和服务进行部署。而对于消费者而言，则需要在这些对等的服务提供方中选择-一个来执行相关的业务逻辑，其中比较典型的就是DNS服务。DNS是域名系统(DomainNameSystem)的缩写，是因特网中使用最广泛的核心技术之一，DNS系统可以看作是一个超大规模的分布式映射表，用于将域名和IP地址进行一一映射，进而方便人们通过域名来访问互联网站点。
- 我们来介绍一种基干ZooKeeper实现的动态DNS方案(以下简称该方案为
“DDNS”, Dynamic DNS)。和配置管理一样，我们首先需要在ZooKeeper上创建一个节点来进行域名配置，例如/DDNS/app1/server:appl.companyl.com (以下简称“域名节点”)。通常应用都会首先从域名节点中获取一份IP地址和端口的配置，进行自行解析。同时，每个应用还会在域名节点上注册一个数据变更Watcher监听，以便及时收到域名变更的通知。

### 3. 命名服务

### 4. 分布式协调/通知

### 5. 集群管理

### 6. Master选举

- 在分布式计算中，Master选举是很重要的一个功能。分布式最核心的特性就是能够将具有独立计算能力的系统单元部署在不同的机器上，构成一个完整的分布式系统。
- 在分布式系统中，Master往往用来协调集群中其他系统单元，具有对分布式系统状态变更的决定权。
- 利用ZooKeeper的强一致性，能够很好地保证在分布式高并发情况下节点的创建一定能够保证全局唯一性，即ZooKeeper将会保证客户端无法重复创建一个已经存在的数据节点。也就是说，如果同时有多个客户端请求创建同一个节点，那么最终一定只有一个客户端请求能够创建成功。利用这个特性，就能很容易地在分布式环境中进行Master选举了。
- 客户端往ZooKeeper上创建一个临时节点，在这个过程中，只有一个客户端能够成功创建这个节点，那么这个客户端所在的机器就成为了Master。同时，其他没有在ZooKeeper上成功创建节点的客户端，都会在节点上注册一个子节点变更的Watcher，用于监控当前的Master机器是否存活，一旦发现当前的Master挂了，那么其余的客户端将会重新进行Master选举。
- 我们可以看到，如果仅仅只是想实现Master选举的话，那么其实只需要有一个能够保证数据唯一性的组件即可，例如关系型数据库的主键模型就是非常不错的选择。但是，如果希望能够快速地进行集群Master动态选举，那么基于ZooKeeper来实现是一个不错的新思路。

### 7. 分布式锁

- 分布式锁是控制分布式系统之间同步访问共享资源的一种方式。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要通过一些互斥手段来防止彼此之间的干扰，以保证一致性，在这种情况下，就需要使用分布式锁了。

**排它锁**

- 排他锁的核心是如何保证当前有且仅有一个事务获得锁，并且锁被释放后，所有正在等待获取锁的事务都能够被通知到。
- 在通常的Java开发编程中，有两种常见的方式可以用来定义锁，分别是synchronized机制和JDK5提供的ReentrantLock。然而，在ZooKeeper中，没有类似于这样的API可以直接使用，而是通过ZooKeeper上的数据节点来表示一个锁，例如/exclusive_ lock/lock节点就可以被定义为一个锁。
- 在需要获取排他锁时，所有的客户端都会试图通过调用create()接口， 在
/exclusive_ lock节点下创建临时子节点/exclusive_ lock/lock。ZooKeeper会保证在所有的客户端中，最终只有一个客户端能够创建成功，那么就可以.认为该客户端获取了锁。同时，所有没有获取到锁的客户端就需要到/exclusive_ lock节点上注册一个子节点变更的Watcher监听，以便实时监听到lock节点的变更情况。
- /exclusive_ lock/lock是一个临时节点，因此在以下两种情况下，都有可能释放锁。
  - 当前获取锁的客户端机器发生宕机，那么ZooKeeper上的这个临时节点就会被移除。
  - 正常执行完业务逻辑后，客户端就会主动将自己创建的临时节点删除。
- 无论在什么情况下移除了lock节点，ZooKeeper都会通知所有在/exclusive_ lock节点上注册了子节点变更Watcher监听的客户端。这些客户端在接收到通知后，再次重新发起分布式锁获取。

**共享锁**

- 共享锁和排他锁最根本的区别在于，加上排他锁后，数据对象只对一个事务可见，而加上共享锁后，数据对所有事务都可见。
- 和排他锁-样，同样是通过ZooKeeper上的数据节点来表示一个锁，是一个类似于
/shared_ lock/[Hostname]-请求类型-序号的临时顺序节点，例如/shared_ lock/
192.168.0.1-R-0000000001，那么，这个节点就代表了一个共享锁
- 根据共享锁的定义，不同的事务都可以同时对同一个数据对象进行读取操作，而更新操作必须在当前没有任何事务进行读写操作的情况下进行。基于这个原则，我们来看看如何通过ZooKeeper的节点来确定分布式读写顺序，大致可以分为如下4个步骤。
  1. 创建完节点后，获取/shared_lock节点下的所有子节点，并对该节点注册子节点变更的Watcher监听。
  2. 确定自己的节点序号在所有子节点中的顺序。
  3. 对于读请求：如果没有比自己序号小的子节点，或是所有比自己序号小的子节点都是读请求，那么表明自己已经成功获取到了共享锁，同时开始执行读取逻辑。如果比自己序号小的子节点中有写请求，那么就需要进入等待。对于写请求：如果自己不是序号最小的子节点，那么就需要进入等待。
  4. 接收到Watcher 通知后，重复步骤1。

  **羊群效应**

### 8. 分布式队列

- 分布式队列，简单地讲分为两大类，一种是常规的先入先出队列，另一种则是要等到队列元素集聚之后才统一安排执行的Barrier模型。

**FIFO**

- 使用ZooKeeper实现FIFO队列，和共享锁的实现非常类似。FIFO队列就类似于一个全写的共享锁模型，大体的设计思路其实非常简单：所有客户端都会到/queue_fifo 这个节点下面创建一个临时顺序节点，例如/queue_fifo/192.168.0.1-0000000001。
- 创建完节点之后，根据如下4个步骤来确定执行顺序。
  1. 通过调用getChildren()接口来获取/queue_fifo节点下的所有子节点，即获取队列中所有的元素。
  2. 确定自己的节点序号在所有子节点中的顺序。
  3. 如果自己不是序号最小的子节点，那么就需要进入等待，同时向比自己序号小的最后一个节点注册Watcher监听。
  4. 接收到Watcher通知后，重复步骤1。

**Barrier**

- Barrier原意是指障碍物、屏障，而在分布式系统中，特指系统之间的一个协调条件，规定了一个队列的元素必须都集聚后才能统一进行安排，否则一直等待。这往往出现在那些大规模分布式并行计算的应用场景上：最终的合并计算需要基于很多并行计算的子结果来进行。这些队列其实是在FIFO队列的基础上进行了增强
- 大致的设计思想如下：开始时，/queue_barrier节点是一个已经存在的默认节点，并且将其节点的数据内容赋值为一个数字n来代表Barrier值，例如n=10表示只有当/queue_barrier节点下的子节点个数达到10后，才会打开Barrier。之后，所有的客户端都会到/queue_barrier节点下创建一个临时节点，例如/queue_barrier/l92.168.0.1。